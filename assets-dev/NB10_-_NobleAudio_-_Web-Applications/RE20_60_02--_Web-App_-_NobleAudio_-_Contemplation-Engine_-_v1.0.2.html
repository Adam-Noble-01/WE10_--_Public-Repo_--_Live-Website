<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <!-- 
    # NobleAudio - Contemplation Engine

    ===============================================================================
    - - - - - - - - - - - - -   WEB APPLICATION NOTES   - - - - - - - - - - - - - -
    Subject :  NobleAudio - Contemplation Engine
    Date    :  [Specify Current Date, e.g., 19-Jul-2024] 
    Version :  Debug v3 (or specify current version)
    ===============================================================================

    KEY FILE INFORMATION
    - Format: A single `.html` file containing all necessary components: HTML structure, embedded CSS, and integrated JavaScript logic.
    - Core Technology: Leverages the Web Audio API for real-time synthesis and effects processing within the browser.
    - Randomization: Utilizes an embedded `seedrandom.js` PRNG (by David Bau) for generating unique sound patches that are recallable via a seed number.
    - Dependencies: Requires only a modern web browser supporting the Web Audio API. No external libraries needed beyond the embedded PRNG.

    DESCRIPTION
    - NobleAudio Contemplation Engine is a touch-first, interactive web application designed for the rapid generation and manipulation of atmospheric, harmonic, and textural sounds.
    - It features a familiar interface with dual XY pads and sliders optimized for tactile performance and expressive control, similar to its sibling project, the Chaos Engine.
    - The engine employs a hybrid synthesis approach, blending granular textures, additive harmonic richness, and subtle FM, driven by a semi-randomized core to encourage sonic discovery.
    - Aimed at sparking creative ideas, this tool excels at generating evolving soundscapes, complex pads, and unique harmonic content suitable for various electronic music styles, particularly those valuing depth and atmosphere.

    DESIGN MANIFEST & PHILOSOPHY

    TARGET SOUND: DEEP, EVOLVING HARMONIC TEXTURES
    - Focuses on creating sounds characterized by depth, introspection, richness, density, and harmony.
    - Explores a spectrum from soothing and pleasant to uneasy and unsettling, beautiful to haunting, calm to restless, embodying a "contemplative" range.
    - Leverages a hybrid engine (granular, additive, FM) to build complex timbres that evolve over time through internal modulation and user interaction.
    - Integrates chord structures and progressions, allowing the generated sounds to possess inherent musicality based on a selected root key.
    - Encourages the discovery of unique sonic environments beyond typical presets.

    INTERACTION: TACTILE & PERFORMATIVE
    - Optimized for touch interaction on tablets and phones in landscape mode, fostering an immediate connection between gesture and sound.
    - Dual XY pads allow for simultaneous two-handed control, enabling expressive, real-time manipulation of multiple sound parameters.
    - Visual feedback through blue indicator circles and crosshairs provides clarity on the current modulation state.
    - Desktop mouse input is supported for single-pad control.

    SYNTHESIS ENGINE: HYBRID & SEMI-RANDOMIZED
    - Architecture combines:
        - Granular Synthesis: Creates textures and evolving sound beds from synthesized micro-sounds (grains). Parameters like grain size, density, pitch variation, and panning are modulated.
        - Additive Synthesis: Builds rich harmonic structures by layering sine wave partials based on selected chord types and a root frequency. Harmonic content and detuning contribute to the core timbre.
        - FM Synthesis: Used subtly, often modulating filter frequency or additive partials, to add textural complexity and movement rather than aggressive tones.
        - Filtering & Effects: Includes dynamic filtering (lowpass, bandpass, etc.) and delay to shape and spatialize the sound.
    - Randomization Mechanic:
        - The "Seed" button generates a completely new patch by randomizing core synthesis parameters AND the modulation matrix.
        - Each seed maps the performance controls (XY pads, sliders, LFOs) to different synthesis parameters (e.g., grain density, filter cutoff, FM depth, harmonic content).
        - Chord progressions and initial chord types are also randomized per seed.
    - Seeded PRNG ensures any generated patch can be precisely recalled using its unique seed number.

    CONTROL PARADIGM: GUIDED EXPLORATION
    - While the seed dictates the initial sonic landscape and control mappings, the user guides the sound's evolution through performance controls:
        - XY Pads: Primary tools for real-time modulation, exploring the sonic possibilities inherent in the current seed. The Y-axis often influences chord changes within the selected progression.
        - Left Slider (Mod Wheel): Spring-back control for momentary expressive changes. Its target parameter is randomized per seed.
        - Right Slider (Intensity Fader): Persistent control adjusting the overall modulation depth/complexity and potentially the inherent brightness or density of the patch. Lower settings yield calmer, perhaps darker results.
        - Key Selector: Locks the generated patch's harmonic foundation to a specific musical root note.
        - Seed Recall: Allows revisiting and further exploring specific sound worlds discovered previously.

    GOAL: SONIC INSPIRATION & TEXTURAL GENERATION
    - The Contemplation Engine serves as an ideation tool for unique atmospheric pads, harmonic textures, and evolving soundscapes.
    - It is designed to complement traditional sound design workflows by rapidly generating novel starting points.
    - The output is well-suited for sampling and further processing within a DAW.
    - Encourages breaking free from conventional sound design habits through embracing serendipity and guided randomization.


    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    END OF NOTES

    -->
    <title>NobleAudio - Contemplation Engine (Debug v3)</title>
    <style>
        :root {
            --pad-size: clamp(150px, 35vmin, 350px);
            /* UPDATED INDICATOR COLOR */
            --indicator-color: skyblue;
            --background-color: #111;
            --pad-background: #222;
            --text-color: #eee;
            --control-bg: #333;
            --control-hover-bg: #444;
            --slider-bg: #2a2a2a;
            --slider-thumb-bg: #555;
            --slider-track-bg: #444;
            --slider-width: clamp(40px, 8vw, 60px);
            --top-bar-height: 60px;
            --side-padding: 15px;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: manipulation;
            min-height: 320px;
             min-width: 480px;
        }

        /* Landscape Enforcement Overlay */
        @media (orientation: portrait) {
            body::before {
                content: "Please rotate your device to Landscape Mode";
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: rgba(0, 0, 0, 0.9);
                color: white;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 1.5em;
                text-align: center;
                padding: 20px;
                z-index: 1000;
            }
             #app-container { display: none; }
        }
        @media (orientation: landscape) {
             #app-container { display: flex; flex-grow: 1; flex-direction: column; }
        }

        #app-container {
            width: 100%;
            height: 100%;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px var(--side-padding);
            height: var(--top-bar-height);
            background-color: #1a1a1a;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        #title {
            font-size: 1.1em;
            font-weight: bold;
            color: #aaa;
            white-space: nowrap;
        }

        #top-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #top-controls button, #top-controls select {
             padding: 8px 12px;
             font-size: 14px;
             background-color: var(--control-bg);
             color: var(--text-color);
             border: 1px solid #555;
             cursor: pointer;
             border-radius: 4px;
             transition: background-color 0.2s ease;
             min-width: 80px;
             text-align: center;
        }
        #top-controls select {
             appearance: none;
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23eee%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 10px auto;
             padding-right: 30px;
        }

        #top-controls button:hover, #top-controls select:hover {
            background-color: var(--control-hover-bg);
        }

         #randomizeButton { min-width: 120px; }
        #seedDisplay { font-weight: bold; color: var(--indicator-color); }

        #main-content {
            display: flex;
            flex-grow: 1;
            align-items: center;
            justify-content: center;
            padding: 10px var(--side-padding);
            gap: 15px;
             width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .slider-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(var(--pad-size) * 1.5);
             min-height: 200px;
             max-height: 80vh;
            width: var(--slider-width);
             background-color: var(--slider-bg);
             border-radius: 5px;
             padding: 10px 0;
             box-sizing: border-box;
             flex-shrink: 0;
        }

        input[type="range"].vertical-slider {
            appearance: slider-vertical;
            width: calc(100% - 20px);
             height: var(--slider-width); /* Track height becomes slider width */
            cursor: pointer;
            background: transparent;
             border: none;
             margin: 0;
             display: block;
        }

        /* Track */
        input[type="range"].vertical-slider::-webkit-slider-runnable-track {
            height: 5px; /* This now controls the width of the track */
            background: var(--slider-track-bg);
            border-radius: 3px;
        }
         input[type="range"].vertical-slider::-moz-range-track {
             height: 5px; /* This now controls the width of the track */
             background: var(--slider-track-bg);
             border-radius: 3px;
        }

        /* Thumb */
        input[type="range"].vertical-slider::-webkit-slider-thumb {
            appearance: none;
             width: 20px;  /* Thumb width */
             height: calc(var(--slider-width) * 0.8); /* Thumb height relative to slider container width */
            background: var(--slider-thumb-bg);
            border-radius: 3px;
            border: 1px solid #777;
            margin-left: -8px; /* Center thumb horizontally on track */
        }
         input[type="range"].vertical-slider::-moz-range-thumb {
             width: 20px;
             height: calc(var(--slider-width) * 0.8);
            background: var(--slider-thumb-bg);
            border-radius: 3px;
            border: 1px solid #777;
        }


        #pads-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-grow: 1;
            height: 100%;
            min-width: calc(var(--pad-size) * 2 + 10px);
        }

        .xy-pad {
            position: relative;
            width: var(--pad-size);
            height: var(--pad-size);
            background-color: var(--pad-background);
            border: 2px solid #444;
            cursor: crosshair;
            touch-action: none;
            user-select: none;
            overflow: hidden;
            border-radius: 5px;
            flex-shrink: 0;
        }

        .indicator {
            position: absolute;
            width: 25px;
            height: 25px;
            border: 2px solid var(--indicator-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            box-shadow: 0 0 8px var(--indicator-color);
        }

        .crosshair {
            position: absolute;
            background-color: var(--indicator-color);
            pointer-events: none;
            display: none;
            opacity: 0.4;
        }

        .crosshair-h {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair-v {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>

    <div id="app-container">

        <div id="top-bar">
            <!-- UPDATED TITLE -->
            <div id="title">NobleAudio - Contemplation Engine</div>
            <div id="top-controls">
                <button id="recallSeedButton">Recall Seed</button>
                <select id="keySelector">
                    <!-- Options added by JS -->
                </select>
                <button id="randomizeButton">Seed: <span id="seedDisplay">N/A</span></button>
            </div>
        </div>

        <div id="main-content">
            <div class="slider-container">
                <input type="range" min="0" max="100" value="50" class="vertical-slider" id="sliderL">
            </div>

            <div id="pads-container">
                <div class="xy-pad" id="xyPad1">
                    <div class="indicator"></div>
                    <div class="crosshair crosshair-h"></div>
                    <div class="crosshair crosshair-v"></div>
                </div>
                <div class="xy-pad" id="xyPad2">
                    <div class="indicator"></div>
                    <div class="crosshair crosshair-h"></div>
                    <div class="crosshair crosshair-v"></div>
                </div>
            </div>

            <div class="slider-container">
                <input type="range" min="0" max="100" value="50" class="vertical-slider" id="sliderR">
            </div>
        </div>
    </div>


    <script>
        // --- Embedded Seedrandom PRNG (Credit: David Bau) ---
        (function(global, pool, math) {
            // --- ARC4 / Seedrandom Library Code (same as before) ---
            var width = 256, chunks = 6, digits = 52, rngname = 'random', startdenom = math.pow(width, chunks),
                significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
            function seedrandom(seed, options, callback) {
                var key = [];
                options = (options == true) ? { entropy: true } : (options || {});
                var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : (seed == null) ? autoseed() : seed, 3), key);
                var arc4 = new ARC4(key);
                var prng = function() {
                    var n = arc4.g(chunks), d = startdenom, x = 0;
                    while (n < significance) { n = (n + x) * width; d *= width; x = arc4.g(1); }
                    while (n >= overflow) { n /= 2; d /= 2; x >>>= 1; }
                    return (n + x) / d;
                };
                prng.int32 = function() { return arc4.g(4) | 0; }
                prng.quick = function() { return arc4.g(4) / 0x100000000; }
                prng.double = prng;
                mixkey(tostring(arc4.S), pool);
                return (options.pass || callback ||
                    function(prng, seed, is_math_call, state) {
                        if (state) {
                            if (state.S) { copy(state, arc4); }
                            prng.state = function() { return copy(arc4, {}); }
                        }
                        if (is_math_call) { math[rngname] = prng; return seed; }
                        else return prng;
                    })(prng, shortseed, 'global' in options ? options.global : (this == math), options.state);
            }
            function ARC4(key) {
                var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
                if (!keylen) { key = [keylen++]; }
                while (i < width) { s[i] = i++; }
                for (i = 0; i < width; i++) {
                    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
                    s[j] = t;
                }
                (me.g = function(count) {
                    var t, r = 0, i = me.i, j = me.j, s = me.S;
                    while (count--) {
                        t = s[i = mask & (i + 1)];
                        r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
                    }
                    me.i = i; me.j = j;
                    return r;
                })(width);
            }
            function copy(f, t) {
                t.i = f.i; t.j = f.j; t.S = f.S.slice(); return t;
            }
            function flatten(obj, depth) {
                var result = [], typ = (typeof obj), prop;
                if (depth && typ == 'object') {
                    for (prop in obj) { try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {} }
                }
                return (result.length ? result : typ == 'string' ? obj : obj + '\0');
            }
            function mixkey(seed, key) {
                var stringseed = seed + '', smear, j = 0;
                while (j < stringseed.length) { key[mask & j] = mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++)); }
                return tostring(key);
            }
            function autoseed() { try { var out; if (nodecrypto && nodecrypto.randomBytes) { out = nodecrypto.randomBytes(width); } else { out = new Uint8Array(width); (global.crypto || global.msCrypto).getRandomValues(out); } return tostring(out); } catch (e) { var pool = global.crypto || global.msCrypto || {}; var arr = pool.getRandomValues && pool.getRandomValues(new Uint8Array(width)); return tostring(arr); } }
            function tostring(a) { return String.fromCharCode.apply(0, a); }
            math['seed' + rngname] = seedrandom; mixkey(math.random(), pool);
        }(this, [], Math));
        // --- End Seedrandom ---

        // --- UI Element References (Same as before) ---
        const xyPad1 = document.getElementById('xyPad1');
        const xyPad2 = document.getElementById('xyPad2');
        const sliderL = document.getElementById('sliderL');
        const sliderR = document.getElementById('sliderR');
        const randomizeButton = document.getElementById('randomizeButton');
        const recallSeedButton = document.getElementById('recallSeedButton');
        const keySelector = document.getElementById('keySelector');
        const seedDisplay = document.getElementById('seedDisplay');

        // --- Audio Context and Node Variables (NEW ENGINE) ---
        let audioContext;
        let mainGain;
        let granularSources = []; // Array to hold { source: AudioBufferSourceNode, gain: GainNode, panner: StereoPannerNode }
        let additiveSynth = { // Object to hold additive components
            oscs: [], // Array of { osc: OscillatorNode, gain: GainNode }
            mainGain: null // GainNode for the additive layer
        };
        let fmSynth = { // Simple FM pair for texture
            modulator: null, // Oscillator
            modGain: null    // GainNode controlling FM depth
        };
        let filter;
        let delay, delayFeedbackGain;
        // let reverb, reverbWetGain; // Reverb might be too heavy/complex initially, start without
        let masterCompressor;
        let lfo1, lfo2, harmonyLFO;
        let lfo1Gain, lfo2Gain, harmonyLFOGain;

        // --- State Variables (Mostly same, adapted for new engine) ---
        const activePointers = new Map();
        const padStates = {
            pad1: { x: 0.5, y: 0.5, active: false },
            pad2: { x: 0.5, y: 0.5, active: false }
        };
        const sliderStates = {
            sliderL: 0.5,
            sliderR: 0.5
        };

        let currentSeed = null;
        let currentKey = 'C2';
        let isAudioEngineRunning = false; // Flag to control granular loop / main gain
        let granularTimeoutId = null; // To manage the granular scheduling loop

        // --- Key Frequencies (EXPANDED to C1-B4) ---
        const keyFrequencies = { // C1 to B4
            // Octave 1
            'C1': 32.70, 'C#1': 34.65, 'D1': 36.71, 'D#1': 38.89, 'E1': 41.20, 'F1': 43.65, 'F#1': 46.25, 'G1': 49.00, 'G#1': 51.91, 'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            // Octave 2
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            // Octave 3
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            // Octave 4
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
        };
        // --- Chord / Harmony Definitions ---
        const chordProgressions = [ // Example progressions of chord types
            // More Minor / Sus / Jazzy focus
            ['minor7th', 'major7th', 'sus4', 'minor9th'], // Melancholic start
            ['major7th', 'dominant7alt', 'minorTriad', 'diminished7th'], // Jazzy tension
            ['sus2', 'minorTriad', 'majorTriad', 'halfDim7th'], // Open -> Minor -> Major -> Tension
            ['minor7th', 'dominant9th', 'minor11th', 'major7th'], // Common Jazz flow
            ['sus4', 'minor7th', 'dominant7th', 'majorTriad'], // Resolution feel
            ['minorTriad', 'minorMaj7th', 'minor6th', 'sus2'], // Darker minor variations
            ['major9th', 'minor7th', 'dominant7alt', 'sus4'], // Brighter start, complex middle
        ];
        const chordTypes = { // Intervals in semitones from root
            'majorTriad': [0, 4, 7],
            'minorTriad': [0, 3, 7],
            'diminishedTriad': [0, 3, 6],
            'augmentedTriad': [0, 4, 8],
            'major7th': [0, 4, 7, 11],
            'minor7th': [0, 3, 7, 10],
            'dominant7th': [0, 4, 7, 10],
            'sus4': [0, 5, 7],
            'sus2': [0, 2, 7],
            'rootOctave': [0, 12],
            // Added Jazzy/Complex Chords
            'minor9th': [0, 3, 7, 10, 14], // Minor 7 + 9th
            'major9th': [0, 4, 7, 11, 14], // Major 7 + 9th
            'dominant9th': [0, 4, 7, 10, 14], // Dominant 7 + 9th
            'minor11th': [0, 3, 7, 10, 14, 17], // Minor 9 + 11th (often omit 3rd/5th in practice)
            'dominant7alt': [0, 4, 8, 10], // Example altered dominant: Root, 3rd, #5, b7
            'diminished7th': [0, 3, 6, 9], // Fully diminished
            'halfDim7th': [0, 3, 6, 10], // Minor 7 b5
            'minorMaj7th': [0, 3, 7, 11], // Minor triad + Major 7th
            'minor6th': [0, 3, 7, 9],     // Minor triad + Major 6th
        };

        // --- Synth Parameters (NEW ENGINE) ---
        let params = {
            // Granular
            numGranularSources: 10, grainBufferType: 'sine', // 'sine', 'saw' - REMOVED 'noise' default
            grainBaseDuration: 0.15, grainDurationVar: 0.1,
            grainDensity: 25, grainOverlap: 0.6, // Density in grains/sec
            grainPitchBase: 0, grainPitchVar: 50, // Base offset (cents), random var (cents)
            grainDetuneSpread: 5, // Random detune per grain (cents)
            grainPanSpread: 0.7, grainBaseGain: 0.08, // SLIGHTLY lower base gain

            // Additive
            additiveHarmonics: 8, additiveBaseGain: 0.10, // SLIGHTLY higher base gain
            additiveHarmonicProfile: 'decay', // 'decay', 'even', 'odd', 'random'
            additiveDetuneSpread: 3, // Increased base detune slightly

            // FM (Texture)
            fmModFreqRatio: 2.5, fmBaseDepth: 15,

            // Filter
            filterType: 'lowpass', filterBaseCutoff: 1000, filterBaseQ: 1.5, // Slightly lower base cutoff

            // Delay
            delayTime: 0.45, delayFeedback: 0.40, delayMix: 0.35, // Slightly higher defaults

            // Reverb (if added later)
            // reverbMix: 0.2, reverbDecay: 2.5,

            // LFOs
            lfo1Freq: 0.8, lfo1BaseDepth: 0, lfo2Freq: 0.3, lfo2BaseDepth: 0,
            harmonyLFOFreq: 0.1, harmonyLFOModAmount: 0.1, // How much LFO affects chord switching

            // Master / Envelope
            masterGain: 0.25, attackTime: 0.1, releaseTime: 0.8,
            compressorThreshold: -18, compressorRatio: 10,

            // Harmony
            baseFrequency: keyFrequencies[currentKey],
            chordProgressionIndex: 0,
            currentChordType: 'minorTriad' // Initial chord type
        };

        // --- Modulation Matrix (NEW TARGETS) ---
        let modMatrix = {};
        const possibleModTargets = [
            // Granular
            'grainDuration', 'grainDensity', 'grainPitchVar', 'grainDetuneSpread',
            'grainPanSpread', 'grainGain', 'grainOverlap',
            // Additive
            'additiveGain', 'additiveHarmonicCount', 'additiveDetune',
            // FM
            'fmDepth', 'fmRatio',
            // Filter
            'filterCutoff', 'filterQ',
            // Delay
            'delayTime', 'delayFeedback', 'delayMix',
            // LFOs
            'lfo1Depth', 'lfo2Depth', 'lfo1Freq', 'lfo2Freq',
            'harmonyRate', // Speed of chord changes (e.g., modulating harmonyLFOFreq)
            // Master
            'mainVol'
            // 'reverbMix', 'reverbDecay' // If reverb added
        ];
        const modSources = ['x1', 'y1', 'x2', 'y2', 'sliderL', 'sliderR', 'lfo1', 'lfo2', 'harmonyLFO']; // Added Harmony LFO as source

        // --- Utility: Clamp ---
        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        // --- Utility: Frequency from Semitones ---
        function freqFromRoot(rootFreq, semitones) {
            return rootFreq * Math.pow(2, semitones / 12);
        }


        // --- Audio Initialization (NEW ENGINE) ---
        function initAudio() {
             // **Return immediately if context already exists**
             if (audioContext) {
                 console.log("initAudio called but context exists. Current state:", audioContext.state);
                 // Ensure nodes needed later exist, or recreate if necessary
                 if (!mainGain || !masterCompressor || !filter || !additiveSynth.mainGain || !delay || !lfo1Gain) {
                     console.warn("Some essential nodes missing despite context existing. Re-initializing nodes.");
                     // Re-create missing essential nodes, but don't recreate context
                     try {
                         if (!mainGain) mainGain = audioContext.createGain();
                         if (!masterCompressor) masterCompressor = audioContext.createDynamicsCompressor();
                         if (!filter) filter = audioContext.createBiquadFilter();
                         if (!additiveSynth.mainGain) additiveSynth.mainGain = audioContext.createGain();
                         if (!delay) delay = audioContext.createDelay(5.0); // Max delay time 5s
                         if (!delayFeedbackGain) delayFeedbackGain = audioContext.createGain();
                         if (!fmSynth.modulator) fmSynth.modulator = audioContext.createOscillator();
                         if (!fmSynth.modGain) fmSynth.modGain = audioContext.createGain();
                         if (!lfo1) lfo1 = audioContext.createOscillator();
                         if (!lfo1Gain) lfo1Gain = audioContext.createGain();
                         if (!lfo2) lfo2 = audioContext.createOscillator();
                         if (!lfo2Gain) lfo2Gain = audioContext.createGain();
                         if (!harmonyLFO) harmonyLFO = audioContext.createOscillator();
                         if (!harmonyLFOGain) harmonyLFOGain = audioContext.createGain();

                         // Re-establish critical connections if missing
                         // This part needs careful checking based on desired signal flow
                         // Example: ensure filter connects to compressor, compressor to mainGain etc.
                         // It's often simpler to just fully re-run setupAndStartNodes if nodes go missing.

                     } catch (e) {
                         console.error("Error recreating missing nodes:", e);
                         return Promise.reject(e); // Signal failure
                     }
                 }
                 return Promise.resolve(audioContext); // Return existing context
             }
            console.log("Attempting to create new AudioContext...");
            return new Promise((resolve, reject) => {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("AudioContext created. Initial state:", audioContext.state);

                    // --- Create Core Nodes ---
                    mainGain = audioContext.createGain();
                    masterCompressor = audioContext.createDynamicsCompressor();
                    filter = audioContext.createBiquadFilter();
                    delay = audioContext.createDelay(5.0); // Max delay 5s
                    delayFeedbackGain = audioContext.createGain();
                    // Reverb Node (if used later)
                    // reverb = audioContext.createConvolver();
                    // reverbWetGain = audioContext.createGain();

                    // --- Create Synth Layer Nodes ---
                    additiveSynth.mainGain = audioContext.createGain(); // Gain for the whole additive layer
                    fmSynth.modulator = audioContext.createOscillator();
                    fmSynth.modGain = audioContext.createGain();

                    // --- Create LFO Nodes ---
                    lfo1 = audioContext.createOscillator();
                    lfo1Gain = audioContext.createGain();
                    lfo2 = audioContext.createOscillator();
                    lfo2Gain = audioContext.createGain();
                    harmonyLFO = audioContext.createOscillator();
                    harmonyLFOGain = audioContext.createGain();

                    // --- Setup Initial Routing ---
                    // Granular sources will connect to filter individually or via a submix
                    // Additive Synth -> Filter
                    if (additiveSynth.mainGain) additiveSynth.mainGain.connect(filter);

                    // Filter -> Delay (Dry/Wet handled later if needed, simple serial for now)
                    filter.connect(delay);

                    // Delay Feedback Loop
                    delay.connect(delayFeedbackGain);
                    delayFeedbackGain.connect(delay);

                    // Delay -> Compressor
                    delay.connect(masterCompressor);
                    // filter.connect(masterCompressor); // Also connect dry signal path? Or just wet? Let's go wet only for now.

                    // Compressor -> Main Gain -> Destination
                    masterCompressor.connect(mainGain);
                    mainGain.connect(audioContext.destination);

                    // LFOs -> Gain Nodes (outputs used for modulation)
                    lfo1.connect(lfo1Gain);
                    lfo2.connect(lfo2Gain);
                    harmonyLFO.connect(harmonyLFOGain);

                    // FM Setup (Modulator -> ModGain -> Target)
                    // Let's target filter frequency for subtle texture
                    if (fmSynth.modulator && fmSynth.modGain && filter) {
                        fmSynth.modulator.connect(fmSynth.modGain);
                        fmSynth.modGain.connect(filter.frequency); // Modulates filter cutoff
                    }

                    // --- Initialize Gains ---
                    mainGain.gain.setValueAtTime(0, audioContext.currentTime); // Start silent
                    if (additiveSynth.mainGain) additiveSynth.mainGain.gain.setValueAtTime(0, audioContext.currentTime);
                    if (fmSynth.modGain) fmSynth.modGain.gain.setValueAtTime(0, audioContext.currentTime);
                    delayFeedbackGain.gain.setValueAtTime(0, audioContext.currentTime);

                    console.log("Audio nodes created and basic routing established.");
                    resolve(audioContext);

                } catch (e) {
                    console.error("Fatal Error during AudioContext/Node creation:", e);
                    alert("Could not initialize audio engine. Error: " + e);
                    reject(e);
                }
            });
        }

        // --- Setup Nodes and Start Continuous Oscillators ---
        function setupAndStartNodes() {
            if (!audioContext || audioContext.state !== 'running') {
                console.warn("Cannot setup nodes, AudioContext not running.");
                return;
            }
             if (!mainGain || !masterCompressor || !filter || !additiveSynth.mainGain || !delay || !lfo1Gain || !fmSynth.modulator) {
                 console.error("Essential audio nodes are missing in setupAndStartNodes. Attempting re-init...");
                 initAudio().then(() => {
                     // Retry setup after re-init attempt
                     if (audioContext && audioContext.state === 'running') {
                         setupAndStartNodes(); // Recursive call after re-init
                     }
                 }).catch(err => {
                     console.error("Re-initialization failed in setupAndStartNodes:", err);
                 });
                 return; // Exit this attempt
             }
            console.log("Setting up and starting audio node parameters...");

            try {
                // --- Stop previous Oscillators if they exist ---
                // This prevents errors if randomizeSeed is called multiple times quickly
                try { if (fmSynth.modulator.context) fmSynth.modulator.stop(); } catch(e){}
                try { if (lfo1.context) lfo1.stop(); } catch(e){}
                try { if (lfo2.context) lfo2.stop(); } catch(e){}
                try { if (harmonyLFO.context) harmonyLFO.stop(); } catch(e){}
                stopAdditiveSynth(); // Stop any existing additive oscillators

                 // --- Recreate oscillators to ensure they can be started again ---
                fmSynth.modulator = audioContext.createOscillator();
                lfo1 = audioContext.createOscillator();
                lfo2 = audioContext.createOscillator();
                harmonyLFO = audioContext.createOscillator();

                 // --- Reconnect oscillators ---
                fmSynth.modulator.connect(fmSynth.modGain);
                lfo1.connect(lfo1Gain);
                lfo2.connect(lfo2Gain);
                harmonyLFO.connect(harmonyLFOGain);

                // --- Granular Source Placeholders (Structure only) ---
                // Clear previous granular sources and their nodes
                granularSources.forEach(g => {
                    try { if(g.source) g.source.disconnect(); } catch(e) {}
                    try { g.gain.disconnect(); } catch(e) {}
                    try { g.panner.disconnect(); } catch(e) {}
                });
                granularSources = [];
                console.log(`Creating structure for ${params.numGranularSources} granular sources...`);
                for (let i = 0; i < params.numGranularSources; i++) {
                    const gain = audioContext.createGain();
                    const panner = audioContext.createStereoPanner();
                    gain.connect(panner);
                    panner.connect(filter); // Connect each grain stream to the filter
                    gain.gain.setValueAtTime(0, audioContext.currentTime); // Start silent
                    panner.pan.setValueAtTime(0, audioContext.currentTime);
                    granularSources.push({ source: null, gain: gain, panner: panner });
                }
                console.log("Granular node structure created.");

                // --- Set Initial Static Parameters ---
                params.baseFrequency = keyFrequencies[currentKey];

                // Additive gain (start silent, controlled by modulation/envelope)
                additiveSynth.mainGain.gain.setTargetAtTime(params.additiveBaseGain, audioContext.currentTime, 0.01);

                // FM Synth
                fmSynth.modulator.type = 'sine';
                fmSynth.modulator.frequency.setTargetAtTime(params.baseFrequency * params.fmModFreqRatio, audioContext.currentTime, 0.01);
                fmSynth.modGain.gain.setTargetAtTime(params.fmBaseDepth, audioContext.currentTime, 0.01); // FM Depth

                // Filter
                filter.type = params.filterType;
                filter.frequency.setTargetAtTime(params.filterBaseCutoff, audioContext.currentTime, 0.01);
                filter.Q.setTargetAtTime(params.filterBaseQ, audioContext.currentTime, 0.01);

                // Delay
                delay.delayTime.setTargetAtTime(params.delayTime, audioContext.currentTime, 0.01);
                delayFeedbackGain.gain.setTargetAtTime(params.delayFeedback, audioContext.currentTime, 0.01);
                // Need proper wet/dry mix for delayMix parameter - simplest is serial for now

                // Compressor
                masterCompressor.threshold.setTargetAtTime(params.compressorThreshold, audioContext.currentTime, 0.01);
                masterCompressor.ratio.setTargetAtTime(params.compressorRatio, audioContext.currentTime, 0.01);
                masterCompressor.attack.setTargetAtTime(0.01, audioContext.currentTime, 0.01); // Quick attack
                masterCompressor.release.setTargetAtTime(0.1, audioContext.currentTime, 0.01); // Quick release

                // LFOs
                lfo1.type = 'sine';
                lfo1.frequency.setTargetAtTime(params.lfo1Freq, audioContext.currentTime, 0.01);
                lfo1Gain.gain.setTargetAtTime(params.lfo1BaseDepth, audioContext.currentTime, 0.01);

                lfo2.type = 'triangle';
                lfo2.frequency.setTargetAtTime(params.lfo2Freq, audioContext.currentTime, 0.01);
                lfo2Gain.gain.setTargetAtTime(params.lfo2BaseDepth, audioContext.currentTime, 0.01);

                harmonyLFO.type = 'sine';
                harmonyLFO.frequency.setTargetAtTime(params.harmonyLFOFreq, audioContext.currentTime, 0.01);
                harmonyLFOGain.gain.setTargetAtTime(params.harmonyLFOModAmount, audioContext.currentTime, 0.01);


                // --- Start Continuous Oscillators ---
                try { fmSynth.modulator.start(); } catch (e) { console.warn("FM Modulator already started?", e); }
                try { lfo1.start(); } catch (e) { console.warn("LFO1 already started?", e); }
                try { lfo2.start(); } catch (e) { console.warn("LFO2 already started?", e); }
                try { harmonyLFO.start(); } catch (e) { console.warn("Harmony LFO already started?", e); }


                console.log("Audio node parameters set and continuous oscillators started.");
                isAudioEngineRunning = false; // Reset flag, loops start on first interaction

            } catch (e) {
                console.error("Error during setupAndStartNodes:", e);
                alert("Error setting up audio nodes: " + e);
            }
        }


        // --- Granular Synthesis Engine ---
        function updateGranularParameters() {
            if (granularTimeoutId) {
                clearTimeout(granularTimeoutId);
                granularTimeoutId = null;
            }

             if (!audioContext || audioContext.state !== 'running' || !isAudioEngineRunning || granularSources.length === 0) {
                 // console.log("Granular loop paused."); // DEBUG
                 return; // Stop loop if paused or not ready
             }
             // console.log("Granular Tick"); // DEBUG

            const now = audioContext.currentTime;
            const density = Math.max(1, params.grainDensity); // Grains per second
            const baseDuration = Math.max(0.01, params.grainBaseDuration); // Min 10ms
            const durationVariation = params.grainDurationVar;
            const basePitchShift = params.grainPitchBase; // In cents
            const pitchVariation = params.grainPitchVar; // In cents
            const detuneSpread = params.grainDetuneSpread; // In cents
            const panSpread = params.grainPanSpread;
            const baseGain = Math.max(0, params.grainBaseGain / granularSources.length); // Distribute gain
            const overlapFactor = clamp(params.grainOverlap, 0.01, 0.98);

            granularSources.forEach(gSource => {
                if (!gSource || !gSource.gain || !gSource.panner) {
                     console.warn("Skipping invalid granular source structure.");
                     return;
                }

                // Calculate Timing
                const scheduleTime = now + (Math.random() / density); // Time to start this grain
                const duration = baseDuration + (Math.random() - 0.5) * 2 * durationVariation;
                if (duration <= 0.005) return; // Skip too short grains

                // --- Create Grain Buffer ---
                const bufferLength = Math.max(4, Math.ceil(audioContext.sampleRate * duration));
                let grainBuffer;
                try {
                    grainBuffer = audioContext.createBuffer(1, bufferLength, audioContext.sampleRate);
                } catch (bufferError) {
                     console.error("Error creating grain buffer:", bufferError, "Length:", bufferLength, "Duration:", duration);
                     return; // Skip this grain
                }
                const data = grainBuffer.getChannelData(0);
                const attackSamples = Math.floor(bufferLength * 0.1); // Quick attack/release
                const releaseSamples = Math.floor(bufferLength * 0.1);
                const sustainSamples = bufferLength - attackSamples - releaseSamples;

                // Simple windowed noise/tone buffer generation
                for (let i = 0; i < bufferLength; i++) {
                    let envelope = 1.0;
                    if (i < attackSamples) envelope = i / attackSamples;
                    else if (i >= bufferLength - releaseSamples && releaseSamples > 0) envelope = (bufferLength - 1 - i) / releaseSamples;

                    let sampleVal = 0;
                    switch(params.grainBufferType) {
                        case 'noise':
                            sampleVal = (Math.random() * 2 - 1);
                            break;
                        case 'sine':
                            sampleVal = Math.sin(2 * Math.PI * 440 * (i / audioContext.sampleRate)); // Placeholder freq
                            break;
                        case 'saw':
                             const phase = (440 * (i / audioContext.sampleRate)) % 1.0;
                             sampleVal = (phase * 2.0) - 1.0;
                             break;
                         default: sampleVal = (Math.random() * 2 - 1);
                    }
                     // Apply a slight squared envelope shape for smoother feel
                    data[i] = sampleVal * (envelope * envelope) * 0.8; // Apply envelope and scale
                }

                // --- Create and Configure Source Node ---
                const source = audioContext.createBufferSource();
                source.buffer = grainBuffer;

                // Pitch / Detune
                const pitchShiftCents = basePitchShift + (Math.random() - 0.5) * 2 * pitchVariation;
                const playbackRate = Math.pow(2, pitchShiftCents / 1200);
                source.playbackRate.setValueAtTime(playbackRate, scheduleTime);

                const detuneAmount = (Math.random() - 0.5) * 2 * detuneSpread;
                source.detune.setValueAtTime(detuneAmount, scheduleTime);

                // Panning
                 const panValue = (Math.random() - 0.5) * 2 * panSpread;
                if (gSource.panner?.pan) { // Check if pan exists
                     gSource.panner.pan.setTargetAtTime(panValue, scheduleTime, 0.01);
                 }

                // Gain Envelope on Grain's Gain Node
                 if (gSource.gain?.gain) { // Check if gain exists
                     gSource.gain.gain.cancelScheduledValues(scheduleTime);
                     gSource.gain.gain.setValueAtTime(0, scheduleTime);
                     gSource.gain.gain.linearRampToValueAtTime(baseGain, scheduleTime + duration * 0.1); // Fade in
                     // Hold gain slightly? Or start fade out? Let's start fade out early for softer texture
                     gSource.gain.gain.linearRampToValueAtTime(0, scheduleTime + duration); // Fade out
                 }

                // Connect and Schedule
                try {
                     source.connect(gSource.gain);
                     source.start(scheduleTime);
                     source.stop(scheduleTime + duration + 0.05); // Stop slightly after scheduled duration
                     source.onended = () => {
                         try { source.disconnect(); } catch(e){} // Disconnect when done
                     };
                 } catch (e) {
                     console.warn("Error scheduling/connecting grain:", e);
                 }
            });

            // Schedule the next batch of grains
            const interval = (1 / density) * (1 - overlapFactor); // Time until next grain *should* start
            granularTimeoutId = setTimeout(updateGranularParameters, Math.max(15, interval * 1000)); // Minimum 15ms interval
        }

        // --- Additive Synthesis Engine ---
        function stopAdditiveSynth() {
            if (additiveSynth && additiveSynth.oscs) {
                const now = audioContext ? audioContext.currentTime : 0;
                 additiveSynth.oscs.forEach(item => {
                     try {
                         if (item.osc && item.osc.context) { // Check if node exists and is valid
                             item.osc.stop(now);
                             item.osc.disconnect();
                         }
                         if (item.gain && item.gain.context) {
                             item.gain.disconnect();
                         }
                     } catch(e) {
                          // console.warn("Error stopping/disconnecting old additive osc:", e);
                     }
                 });
                 additiveSynth.oscs = []; // Clear the array
            }
        }

        function updateAdditiveHarmonics() {
             if (!audioContext || audioContext.state !== 'running' || !additiveSynth.mainGain) {
                 console.warn("Cannot update additive harmonics, context/node not ready.");
                 return;
             }
             // console.log("Updating Additive Harmonics for chord:", params.currentChordType); // DEBUG

             stopAdditiveSynth(); // Stop and clear previous oscillators

             const now = audioContext.currentTime;
             const numHarmonics = clamp(Math.round(params.additiveHarmonics), 1, 32); // Limit harmonics
             const baseFreq = params.baseFrequency;
             const chordIntervals = chordTypes[params.currentChordType] || [0]; // Get intervals or default to root
            const gainProfile = params.additiveHarmonicProfile;
            const detuneSpread = params.additiveDetuneSpread; // Cents

             // HUMANIZATION FACTOR (Velocity scaling per partial)
            const velocityRange = 0.2; // e.g., 0.2 means gain can be 80% - 100% of calculated value
             // HUMANIZATION FACTOR (Timing offset per partial)
            const timingSpread = 0.005; // Max 5ms random offset

            if (isNaN(baseFreq) || baseFreq <= 0) {
                console.warn("Invalid baseFrequency for additive synthesis:", baseFreq);
                return;
            }

            // Adjust base gain per harmonic based on chord complexity (more notes = quieter individual partials)
            const complexityFactor = Math.max(1, chordIntervals.length);
            const baseGainPerHarmonic = params.additiveBaseGain / (numHarmonics * complexityFactor);


            chordIntervals.forEach(intervalSemitones => {
                const noteBaseFreq = freqFromRoot(baseFreq, intervalSemitones);

                 for (let i = 1; i <= numHarmonics; i++) {
                    const harmonicFreq = noteBaseFreq * i;
                    if (isNaN(harmonicFreq) || harmonicFreq <= 0 || harmonicFreq > audioContext.sampleRate / 2) continue; // Skip invalid frequencies

                    // Gain calculation based on profile
                     let harmonicGain = baseGainPerHarmonic;
                     switch(gainProfile) {
                         case 'decay': harmonicGain *= (1 / i); break;
                         case 'even': if(i % 2 !== 0) harmonicGain *= 0.1; break; // Attenuate odd
                         case 'odd': if(i % 2 === 0) harmonicGain *= 0.1; break; // Attenuate even
                         case 'random': harmonicGain *= Math.random(); break;
                         default: harmonicGain *= (1 / i); // Default decay
                     }

                     // HUMANIZATION: Apply random velocity scaling
                    const velocityScaler = 1.0 - (Math.random() * velocityRange);
                     harmonicGain *= velocityScaler;

                     harmonicGain = Math.max(0, harmonicGain); // Ensure non-negative gain

                     // Create nodes
                     const osc = audioContext.createOscillator();
                     const gainNode = audioContext.createGain();

                     osc.type = 'sine';
                     osc.frequency.setValueAtTime(harmonicFreq, now);

                     // Add slight random detune to each partial for richness
                     const detuneAmount = (Math.random() - 0.5) * 2 * detuneSpread;
                     osc.detune.setValueAtTime(detuneAmount, now);

                     gainNode.gain.setValueAtTime(0, now); // Start silent
                     gainNode.gain.linearRampToValueAtTime(harmonicGain, now + 0.05); // Quick fade in

                     // Connect
                     osc.connect(gainNode);
                     gainNode.connect(additiveSynth.mainGain); // Connect to additive submix gain

                     try {
                        // HUMANIZATION: Apply random timing offset
                        const startOffset = Math.random() * timingSpread;
                        osc.start(now + startOffset);
                        additiveSynth.oscs.push({ osc: osc, gain: gainNode }); // Track
                     } catch(startError) {
                         console.warn("Error starting additive oscillator:", startError);
                     }
                }
            });
        }

        // --- Randomization (Adapted for NEW ENGINE) ---
        function randomizeSeed(seed = null) {
            // Ensure context exists and is running first
             const initPromise = audioContext ? Promise.resolve(audioContext) : initAudio();

             initPromise.then(ctx => {
                 if (!ctx) throw new Error("AudioContext failed to initialize.");
                 if (ctx.state === 'suspended') {
                     console.log("Audio context suspended, attempting resume for randomizeSeed...");
                     return ctx.resume().then(() => ctx);
                 }
                 return ctx;
             }).then(runningCtx => {
                 if (runningCtx.state !== 'running') {
                     throw new Error("Audio Context not running after resume attempt.");
                 }
                 // --- Proceed with randomization ---
                 proceedWithRandomization(seed); // Pass context implicitly
             }).catch(err => {
                 console.error("Error during context initialization/resume for randomizeSeed:", err);
                 alert("Audio setup failed. Please try interacting again. " + err.message);
             });
        }

        function proceedWithRandomization(seed = null) {
            console.log("Proceeding with randomization...");
            if (!audioContext || audioContext.state !== 'running') {
                 console.error("Cannot proceed with randomization, AudioContext not running.");
                 return;
            }

            // --- Stop existing sound generation ---
            isAudioEngineRunning = false; // Stop granular loop
            if (granularTimeoutId) clearTimeout(granularTimeoutId);
            granularTimeoutId = null;
            stopAdditiveSynth(); // Stop additive oscs
            // Fade out main gain quickly before changing params
            if (mainGain) mainGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);

            // --- Seed PRNG ---
             if (seed === null || typeof seed !== 'number' || isNaN(seed)) {
                currentSeed = Math.floor(Math.random() * 1000000);
            } else {
                 currentSeed = Math.floor(seed);
             }
             Math.seedrandom(currentSeed.toString());
             console.log("Contemplation Engine - Using Seed:", currentSeed);
             seedDisplay.textContent = currentSeed;

             // --- Randomize Params Object (NEW ENGINE) ---
             params.baseFrequency = keyFrequencies[currentKey];
             const filterTypes = ['lowpass', 'bandpass']; // Bias away from highpass/notch for less harshness
             const grainBufferTypes = ['sine', 'saw']; // EXCLUDE 'noise'
             const harmonicProfiles = ['decay', 'even', 'odd', 'random'];

             // Granular (Less Intense Settings - ADJUSTED)
             params.numGranularSources = Math.floor(Math.random() * 6) + 3; // 3-8 sources (Reduced Max)
             params.grainBufferType = grainBufferTypes[Math.floor(Math.random() * grainBufferTypes.length)];
             params.grainBaseDuration = 0.08 + Math.random() * 0.5; // 80ms - 580ms
             params.grainDurationVar = params.grainBaseDuration * (0.1 + Math.random() * 0.6);
             params.grainDensity = 4 + Math.random() * 20; // 4-24 grains/sec (Reduced Max)
             params.grainOverlap = 0.2 + Math.random() * 0.7;
             params.grainPitchBase = (Math.random() - 0.5) * 200;
             params.grainPitchVar = Math.random() * 400;
             params.grainDetuneSpread = Math.random() * 15;
             params.grainPanSpread = Math.random() * 0.8;
             params.grainBaseGain = 0.04 + Math.random() * 0.1;

             // Additive (More Prominent)
             params.additiveHarmonics = Math.floor(Math.random() * 12) + 6; // 6-18 harmonics
             params.additiveBaseGain = 0.06 + Math.random() * 0.16;
             params.additiveHarmonicProfile = harmonicProfiles[Math.floor(Math.random() * harmonicProfiles.length)];
             params.additiveDetuneSpread = 2 + Math.random() * 18;

             // FM (Subtle -> More Present - ADJUSTED)
             params.fmModFreqRatio = 0.5 + Math.random() * 6; // Increased max ratio (0.5-6.5)
             params.fmBaseDepth = 20 + Math.random() * 150; // Increased min and max FM depth (20-170)

             // Filter (Softer)
             params.filterType = filterTypes[Math.floor(Math.random() * filterTypes.length)];
             params.filterBaseCutoff = 80 + Math.random() * 3500;
             params.filterBaseQ = 0.5 + Math.random() * 5;

             // Delay (More Atmospheric)
             params.delayTime = 0.15 + Math.random() * 1.2;
             params.delayFeedback = 0.1 + Math.random() * 0.6;
             params.delayMix = 0.1 + Math.random() * 0.5;

             // LFOs
             params.lfo1Freq = 0.05 + Math.random() * 4;
             params.lfo1BaseDepth = Math.random() < 0.3 ? 0 : Math.random() * 80;
             params.lfo2Freq = 0.02 + Math.random() * 1.5;
             params.lfo2BaseDepth = Math.random() < 0.4 ? 0 : Math.random() * 60;
             params.harmonyLFOFreq = 0.01 + Math.random() * 0.15;
             params.harmonyLFOModAmount = Math.random() * 0.15;

             // Master / Envelope (Slightly Softer)
             params.masterGain = 0.18 + Math.random() * 0.14;
             params.attackTime = 0.1 + Math.random() * 0.6;
             params.releaseTime = 0.5 + Math.random() * 2.0;
             params.compressorThreshold = -25 - Math.random() * 20;
             params.compressorRatio = 3 + Math.random() * 9;

             // Harmony
             params.chordProgressionIndex = Math.floor(Math.random() * chordProgressions.length);
             params.currentChordType = chordProgressions[params.chordProgressionIndex][0]; // Start with first chord

             // --- Apply Static Params & Restart Continuous Nodes ---
             setupAndStartNodes(); // Re-initializes structures, applies static params, starts LFOs/FM

             // --- Randomize Mod Matrix ---
             modMatrix = {};
             const targetsUsed = new Set();
             modSources.forEach(source => {
                 if (source === 'sliderR') return; // Handle chaos separately
                 if (Math.random() < 0.7) { // ~70% chance per source
                     let potentialTargets = possibleModTargets.filter(t => !targetsUsed.has(t));
                     // Avoid LFOs modulating main volume directly
                     if (source.startsWith('lfo')) potentialTargets = potentialTargets.filter(t => t !== 'mainVol');
                     if (potentialTargets.length === 0) potentialTargets = possibleModTargets.filter(t => t !== 'mainVol');
                     if (potentialTargets.length === 0) potentialTargets = possibleModTargets; // Fallback

                     if (potentialTargets.length > 0) {
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        targetsUsed.add(target);

                         let amount;
                         const bipolar = source === 'sliderL' || Math.random() > 0.4; // Slider L and ~60% others are bipolar
                         let scale = bipolar ? (Math.random() * 2 - 1) : Math.random();
                         let baseValue = params[target] ?? 0; // Get current base value

                         // Define modulation amounts based on target (adjust scales as needed)
                         switch (target) {
                             case 'grainDuration': amount = scale * 0.3; baseValue = params.grainBaseDuration; break;
                             case 'grainDensity': amount = scale * 40; baseValue = params.grainDensity; break;
                             case 'grainPitchVar': amount = scale * 800; baseValue = params.grainPitchVar; break;
                             case 'grainDetuneSpread': amount = scale * 40; baseValue = params.grainDetuneSpread; break;
                             case 'grainPanSpread': amount = scale * 1.0; baseValue = params.grainPanSpread; break;
                             case 'grainGain': amount = scale * (params.grainBaseGain * 1.5); baseValue = params.grainBaseGain; break;
                             case 'grainOverlap': amount = scale * 0.8; baseValue = params.grainOverlap; break;
                             case 'additiveGain': amount = scale * (params.additiveBaseGain * 1.8); baseValue = params.additiveBaseGain; break;
                             case 'additiveHarmonicCount': amount = Math.round(scale * 10); baseValue = params.additiveHarmonics; break; // Modulate count
                             case 'additiveDetune': amount = scale * 20; baseValue = params.additiveDetuneSpread; break;
                             // ADJUSTED FM Modulation Amounts
                             case 'fmDepth': amount = scale * 800; baseValue = params.fmBaseDepth; break; // Increased mod amount
                             case 'fmRatio': amount = scale * 8; baseValue = params.fmModFreqRatio; break; // Increased mod amount
                             case 'filterCutoff': amount = scale * 6000; baseValue = params.filterBaseCutoff; break;
                             case 'filterQ': amount = scale * 15; baseValue = params.filterBaseQ; break;
                             case 'delayTime': amount = scale * 1.5; baseValue = params.delayTime; break;
                             case 'delayFeedback': amount = scale * 0.7; baseValue = params.delayFeedback; break;
                             case 'delayMix': amount = scale * 0.6; baseValue = params.delayMix; break;
                             case 'lfo1Depth': amount = scale * 150; baseValue = params.lfo1BaseDepth; break;
                             case 'lfo2Depth': amount = scale * 120; baseValue = params.lfo2BaseDepth; break;
                             case 'lfo1Freq': amount = scale * 8; baseValue = params.lfo1Freq; break;
                             case 'lfo2Freq': amount = scale * 4; baseValue = params.lfo2Freq; break;
                             case 'harmonyRate': amount = scale * 0.3; baseValue = params.harmonyLFOFreq; break;
                             case 'mainVol': amount = scale * (params.masterGain * 0.7); baseValue = params.masterGain; break;
                             default: amount = scale * 50; baseValue = 0;
                         }
                         modMatrix[source] = { target, amount, baseValue };
                    }
                }
             });

             console.log("Contemplation Engine - Randomized Params:", params);
             console.log("Contemplation Engine - Randomized Mod Matrix:", modMatrix);

             // Reset sliders
             sliderL.value = 50; sliderStates.sliderL = 0.5;
             sliderR.value = 50; sliderStates.sliderR = 0.5;

             // Generate initial additive sound & apply initial mod state
             updateAdditiveHarmonics();
             updateSynthParams(true); // Force update with base values + slider positions

             // If pads were held during randomize, restart engine loops immediately
             if (activePointers.size > 0) {
                  console.log("Restarting audio engine loops after randomize while pad held.");
                  isAudioEngineRunning = true;
                  // Ramp up gain quickly
                  const targetGain = calculateTargetMainGain(true); // Calculate gain based on current state
                  if(mainGain) mainGain.gain.setTargetAtTime(targetGain, audioContext.currentTime, params.attackTime * 0.5); // Faster attack after randomize
                  updateGranularParameters(); // Start granular loop
                  updateAdditiveHarmonics(); // Ensure additive synth is running
             }
        }


         // --- Update Synth Parameters (Applying Modulation) ---
         function updateSynthParams(forceBase = false) {
             if (!audioContext || audioContext.state !== 'running' || !mainGain || !filter || !additiveSynth.mainGain || !fmSynth.modGain || !delayFeedbackGain || !lfo1Gain || !lfo2Gain || !harmonyLFOGain) {
                 // console.warn("Cannot update synth params, nodes missing or context not running."); // DEBUG
                 return;
             }
             // console.log("Updating Synth Params..."); // DEBUG

             const now = audioContext.currentTime;
             const smoothTime = 0.025; // Smoothing time for param changes

             // Get current control states
             const x1 = padStates.pad1.active || forceBase ? padStates.pad1.x : 0.5;
             const y1 = padStates.pad1.active || forceBase ? padStates.pad1.y : 0.5;
             const x2 = padStates.pad2.active || forceBase ? padStates.pad2.x : 0.5;
             const y2 = padStates.pad2.active || forceBase ? padStates.pad2.y : 0.5;
             const slL = sliderStates.sliderL; // 0..1
             const slR = sliderStates.sliderR; // 0..1 (Chaos/Intensity)

             const bipolarSliderL = slL - 0.5; // -0.5 to +0.5

             // Get current LFO output values (approx from gain node)
             const lfo1Val = lfo1Gain.gain.value;
             const lfo2Val = lfo2Gain.gain.value;
             const harmonyLFOVal = harmonyLFOGain.gain.value; // For modulating chord changes perhaps

             // --- Chaos Factor (Slider R) ---
             // Scales the *amount* of modulation applied by XY/SliderL
             const chaosFactor = slR * 1.8; // 0 to 1.8 scaling
             // Also make base filter cutoff and FM depth darker/quieter at low chaos settings
             const intensityScale = 0.4 + slR * 0.6; // 0.4 to 1.0 scaling
             let currentFilterBaseCutoff = params.filterBaseCutoff * intensityScale;
             let currentFmBaseDepth = params.fmBaseDepth * intensityScale;
             // let currentAdditiveBaseGain = params.additiveBaseGain * intensityScale; // Scale additive layer too? Maybe.
             // let currentGrainBaseGain = params.grainBaseGain * intensityScale; // Scale grains?

             // --- Modulation Source Values Map ---
             const modValues = {
                 x1, y1, x2, y2,
                 sliderL: bipolarSliderL,
                 lfo1: lfo1Val, lfo2: lfo2Val, harmonyLFO: harmonyLFOVal
                 // sliderR (Chaos) is not a direct source, it scales others
             };

             // --- Helper to Apply Modulation ---
             const applyMod = (targetParam, baseValue, targetNode, allowChaosScaling = true) => {
                 let totalMod = 0;
                 modSources.forEach(source => {
                     // Skip sliderR as direct source, it's a scaler
                     if (source === 'sliderR') return;

                     const modData = modMatrix[source];
                     if (modData && modData.target === targetParam) {
                         let modInput = modValues[source] ?? 0;
                         let effectiveAmount = modData.amount ?? 0;

                         // Apply Chaos Scaling to XY/SliderL modulation amounts
                         if (allowChaosScaling && ['x1', 'y1', 'x2', 'y2', 'sliderL'].includes(source)) {
                             effectiveAmount *= chaosFactor;
                         }
                         totalMod += modInput * effectiveAmount;
                     }
                 });

                 let numericBaseValue = (typeof baseValue === 'number' && !isNaN(baseValue)) ? baseValue : 0;
                 let finalValue = numericBaseValue + totalMod;

                 // --- Update Target Node or Param ---
                 if (targetNode && targetNode.constructor.name === 'AudioParam') {
                     // Clamp values appropriately
                     const minVal = targetNode.minValue ?? -3.4e38;
                     const maxVal = targetNode.maxValue ?? 3.4e38;
                     if (targetParam === 'filterCutoff') finalValue = clamp(finalValue, 20, audioContext.sampleRate / 2 * 0.95);
                     else if (targetParam === 'filterQ') finalValue = clamp(finalValue, 0.01, 30);
                     else if (targetParam.includes('Freq')) finalValue = Math.max(0.001, finalValue); // Freqs positive
                     else if (targetParam.includes('Gain') || targetParam === 'mainVol' || targetParam.includes('Mix') || targetParam.includes('Depth') || targetParam.includes('Amount')) finalValue = Math.max(0, finalValue); // Gains/Mixes positive
                     else if (targetParam === 'delayFeedback') finalValue = clamp(finalValue, 0, 0.98);
                     else if (targetParam === 'delayTime') finalValue = clamp(finalValue, 0.001, 4.9);
                     else finalValue = clamp(finalValue, minVal, maxVal); // General clamp

                     targetNode.setTargetAtTime(finalValue, now, smoothTime);

                 } else if (params.hasOwnProperty(targetParam)) {
                     // Update internal 'params' for non-AudioParam targets (like granular settings)
                     // Apply reasonable clamps here too
                     if (targetParam === 'grainDuration') params.grainBaseDuration = clamp(finalValue, 0.01, 1.5);
                     else if (targetParam === 'grainDensity') params.grainDensity = clamp(finalValue, 1, 100);
                     else if (targetParam === 'grainPitchVar') params.grainPitchVar = clamp(finalValue, 0, 1200);
                     else if (targetParam === 'grainDetuneSpread') params.grainDetuneSpread = clamp(finalValue, 0, 100);
                     else if (targetParam === 'grainPanSpread') params.grainPanSpread = clamp(finalValue, 0, 1.0);
                     else if (targetParam === 'grainGain') params.grainBaseGain = clamp(finalValue, 0.01, 0.4); // Adjust clamp
                     else if (targetParam === 'grainOverlap') params.grainOverlap = clamp(finalValue, 0.01, 0.98);
                     else if (targetParam === 'additiveHarmonicCount') params.additiveHarmonics = clamp(Math.round(finalValue), 1, 32); // Round and clamp
                     else if (targetParam === 'additiveDetune') params.additiveDetuneSpread = clamp(finalValue, 0, 50);
                     else if (targetParam === 'fmRatio') params.fmModFreqRatio = clamp(finalValue, 0.1, 10);
                     // Potentially update other params if needed
                 }
                 return finalValue; // Return the calculated (potentially clamped) value
             };

             // --- Apply Modulations to Audio Nodes ---
             applyMod('additiveGain', params.additiveBaseGain, additiveSynth.mainGain?.gain, true); // Added additive layer gain mod
             applyMod('fmDepth', currentFmBaseDepth, fmSynth.modGain?.gain, true);
             applyMod('filterCutoff', currentFilterBaseCutoff, filter?.frequency);
             applyMod('filterQ', params.filterBaseQ, filter?.Q);
             applyMod('delayFeedback', params.delayFeedback, delayFeedbackGain?.gain);
             applyMod('delayTime', params.delayTime, delay?.delayTime);
             applyMod('lfo1Depth', params.lfo1BaseDepth, lfo1Gain?.gain);
             applyMod('lfo2Depth', params.lfo2BaseDepth, lfo2Gain?.gain);
             applyMod('harmonyRate', params.harmonyLFOFreq, harmonyLFO?.frequency, false); // Modulate harmony LFO rate itself?

             // --- Apply Modulations to Internal Params (Granular, Additive Counts etc) ---
             applyMod('grainDuration', params.grainBaseDuration, null, true);
             applyMod('grainDensity', params.grainDensity, null, true);
             applyMod('grainPitchVar', params.grainPitchVar, null, true);
             applyMod('grainDetuneSpread', params.grainDetuneSpread, null, true);
             applyMod('grainPanSpread', params.grainPanSpread, null, true);
             applyMod('grainGain', params.grainBaseGain, null, true);
             applyMod('grainOverlap', params.grainOverlap, null, true);
             const needsAdditiveUpdate = applyMod('additiveHarmonicCount', params.additiveHarmonics, null, false) !== params.additiveHarmonics; // Check if count changed
             applyMod('additiveDetune', params.additiveDetuneSpread, null, false);
             applyMod('fmRatio', params.fmModFreqRatio, null, true);

            // Apply LFO Frequency Mods (don't scale by chaos?)
            applyMod('lfo1Freq', params.lfo1Freq, lfo1?.frequency, false);
            applyMod('lfo2Freq', params.lfo2Freq, lfo2?.frequency, false);


             // --- Handle Harmony / Chord Changes ---
            // Use average Y position of active pads OR harmony LFO to select chord
            let chordSelectorValue = 0.5; // Default middle
            let activePadCount = 0;
            let sumY = 0;
            activePointers.forEach(pInfo => {
                 if (padStates[pInfo.padId]?.active) {
                     sumY += padStates[pInfo.padId].y;
                     activePadCount++;
                 }
             });
             if (activePadCount > 0) {
                 chordSelectorValue = sumY / activePadCount;
             } else if (harmonyLFOVal > 0.01) { // Use LFO if pads inactive but LFO has depth
                 // Map bipolar LFO (-depth to +depth) to 0-1 range
                 // This needs refinement based on how harmonyLFOVal is scaled by its gain
                 // Assuming harmonyLFOGain outputs something like -0.1 to +0.1 based on params.harmonyLFOModAmount
                  chordSelectorValue = 0.5 + (harmonyLFOVal / (params.harmonyLFOModAmount * 2 + 0.001)); // Map to ~0-1
                  chordSelectorValue = clamp(chordSelectorValue, 0, 1);
             }

            const progression = chordProgressions[params.chordProgressionIndex];
            const chordIndex = Math.floor(chordSelectorValue * progression.length) % progression.length;
            const newChordType = progression[chordIndex];

             // If chord type changed OR if harmonic count changed, update the additive synth
            if (newChordType !== params.currentChordType || needsAdditiveUpdate) {
                 params.currentChordType = newChordType;
                 updateAdditiveHarmonics(); // Rebuild additive oscillators for the new chord/count
             }

             // --- Update Master Volume (Handled in Pointer Up/Down for Attack/Release) ---
             // The target gain is calculated there, here we just ensure continuous modulation applies if active
             if (isAudioEngineRunning) {
                 const targetGain = calculateTargetMainGain(); // Calculate based on current mods
                 mainGain.gain.setTargetAtTime(targetGain, now, smoothTime); // Smoothly track modulated volume
             }

              // Update FM modulator frequency based on current *modulated* base frequency
             const currentBaseFreq = filter.frequency.value; // Use filter freq as a proxy? Or need dedicated node? Let's stick to param baseFreq.
             const fmTargetFreq = params.baseFrequency * applyMod('fmRatio', params.fmModFreqRatio, null, true);
             if (fmSynth.modulator?.frequency) fmSynth.modulator.frequency.setTargetAtTime(fmTargetFreq, now, smoothTime);


         }


        // --- Event Handling (Pads - Mostly Same Structure) ---
        function handlePointerDown(e) {
            // console.log("Pointer Down Fired"); // DEBUG
            let didInitOrResume = false;

            const initOrResumePromise = (!audioContext)
                ? initAudio().then(ctx => { didInitOrResume = true; return ctx; })
                : (audioContext.state === 'suspended')
                    ? audioContext.resume().then(() => { didInitOrResume = true; console.log("AudioContext Resumed."); return audioContext; })
                    : Promise.resolve(audioContext);

            initOrResumePromise.then(runningCtx => {
                if (!runningCtx || runningCtx.state !== 'running') {
                    throw new Error("Audio Context failed to start or resume.");
                }
                // console.log("Audio Context Running, Processing Pointer Down"); // DEBUG

                // If we just initialized, randomize!
                if (didInitOrResume && !currentSeed) {
                    console.log("First interaction: Randomizing initial seed.");
                    proceedWithRandomization(null); // Generate and apply first seed
                    // setupAndStartNodes() and updateAdditiveHarmonics() are called within proceedWithRandomization
                }

                const pad = e.target.closest('.xy-pad');
                if (!pad) return;
                e.preventDefault();

                const padId = pad.id === 'xyPad1' ? 'pad1' : 'pad2';
                if (activePointers.has(e.pointerId)) return; // Already tracking

                const pointerInfo = { padId, lastX: 0.5, lastY: 0.5, lastTime: performance.now(), currentX: 0.5, currentY: 0.5 };
                activePointers.set(e.pointerId, pointerInfo);
                try { pad.setPointerCapture(e.pointerId); } catch (err) { console.error("Pointer capture error:", err); }
                padStates[padId].active = true;

                // --- Visuals ---
                const indicator = pad.querySelector('.indicator');
                const crossH = pad.querySelector('.crosshair-h');
                const crossV = pad.querySelector('.crosshair-v');
                if (indicator) indicator.style.display = 'block';
                if (crossH) crossH.style.display = 'block';
                if (crossV) crossV.style.display = 'block';
                updatePointerPosition(e, pad); // Set initial position

                // --- Start Audio Engine if First Active Pad ---
                let activePadCount = 0;
                activePointers.forEach(info => { if (padStates[info.padId]?.active) activePadCount++; });
                // console.log("Active pad count on down:", activePadCount); // DEBUG

                if (activePadCount === 1) {
                    console.log("First pad press - Starting engine loops.");
                    isAudioEngineRunning = true;
                    // Start granular loop
                    updateGranularParameters();
                    // Ensure additive synth is built for the current state
                    updateAdditiveHarmonics();
                    // Ramp up gain using Attack time
                    if (mainGain) {
                        mainGain.gain.cancelScheduledValues(audioContext.currentTime);
                        const targetGain = calculateTargetMainGain(true); // Get target gain including mods
                        mainGain.gain.setTargetAtTime(targetGain, audioContext.currentTime, params.attackTime);
                        // console.log(`Attack: Ramping mainGain to ${targetGain.toFixed(3)} over ${params.attackTime}s`); // DEBUG
                    }
                }

                // Update synth params based on this new touch/state
                updateSynthParams();

            }).catch(err => {
                console.error("Error in handlePointerDown:", err);
                alert("Audio could not be started. Please interact with the page again or check browser permissions. Error: " + err.message);
            });
        }


        function handlePointerMove(e) {
            if (!activePointers.has(e.pointerId) || !isAudioEngineRunning) return; // Only process if engine is on
            e.preventDefault();

            const pointerInfo = activePointers.get(e.pointerId);
            const padId = pointerInfo.padId;
            const pad = document.getElementById(padId === 'pad1' ? 'xyPad1' : 'xyPad2');
            if (!padStates[padId]?.active) return;

            updatePointerPosition(e, pad);
            // Wiggle effect removed for Contemplation Engine
            updateSynthParams(); // Update synth continuously
        }

        function handlePointerUpOrLeave(e) {
            if (!activePointers.has(e.pointerId)) return;
            e.preventDefault();

            const pointerInfo = activePointers.get(e.pointerId);
            const padId = pointerInfo.padId;
            const pad = document.getElementById(padId === 'pad1' ? 'xyPad1' : 'xyPad2');

            try {
                if (pad && pad.hasPointerCapture && pad.hasPointerCapture(e.pointerId)) {
                    pad.releasePointerCapture(e.pointerId);
                }
            } catch (err) { console.error("Error releasing pointer capture:", err); }

            activePointers.delete(e.pointerId);
            padStates[padId].active = false;

            // Hide visuals
            if (pad) {
                const indicator = pad.querySelector('.indicator');
                const crossH = pad.querySelector('.crosshair-h');
                const crossV = pad.querySelector('.crosshair-v');
                if(indicator) indicator.style.display = 'none';
                if(crossH) crossH.style.display = 'none';
                if(crossV) crossV.style.display = 'none';
            }

            // Check if any pads are still active
            let anyPadActive = false;
            activePointers.forEach(info => { if (padStates[info.padId]?.active) anyPadActive = true; });
            // console.log("Any pad active after up/leave:", anyPadActive); // DEBUG

            if (!anyPadActive) {
                console.log("Last pad released - Stopping engine loops & Fading out.");
                isAudioEngineRunning = false; // Stop granular loop via its check
                if (granularTimeoutId) {
                    clearTimeout(granularTimeoutId);
                    granularTimeoutId = null;
                }
                // Optionally stop additive synth immediately, or let it decay with main gain
                // stopAdditiveSynth(); // Immediate stop

                // Ramp down main gain using Release time
                if (mainGain && audioContext && audioContext.state === 'running') {
                    mainGain.gain.cancelScheduledValues(audioContext.currentTime);
                    mainGain.gain.setTargetAtTime(0, audioContext.currentTime, params.releaseTime);
                    // console.log(`Release: Ramping mainGain to 0 over ${params.releaseTime}s`); // DEBUG
                }
            } else {
                 // console.log("Pad released, but others active. Updating params."); // DEBUG
                // If one pad released but others active, update params to reflect new state
                updateSynthParams();
            }
        }

         // --- Helper to update XY state & visuals (Same as before) ---
         function updatePointerPosition(e, pad) {
            const rect = pad.getBoundingClientRect();
            const padId = pad.id === 'xyPad1' ? 'pad1' : 'pad2';
            const pointerInfo = activePointers.get(e.pointerId);
            if(!pointerInfo) return;

            let x = clamp((e.clientX - rect.left) / rect.width, 0, 1);
            let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
            y = 1 - y; // Flip Y: 0=bottom, 1=top

            padStates[padId].x = x;
            padStates[padId].y = y;
            pointerInfo.currentX = x;
            pointerInfo.currentY = y;

             // Update visuals
             const indicator = pad.querySelector('.indicator');
             const crossH = pad.querySelector('.crosshair-h');
             const crossV = pad.querySelector('.crosshair-v');
             if (!indicator || !crossH || !crossV) return;

             const displayX = x * 100;
             const displayY = (1 - y) * 100; // Original Y for CSS top

             indicator.style.left = `${displayX}%`;
             indicator.style.top = `${displayY}%`;
             crossH.style.top = `${displayY}%`;
             crossV.style.left = `${displayX}%`;
         }

         // --- Calculate Target Main Gain (considering mods AND Y-position proxy) ---
         // Used for attack ramp and continuous updates
         function calculateTargetMainGain(forceActive = false) {
             if (!audioContext || !params || !mainGain) return 0;

             // Only calculate non-zero gain if engine is supposed to be running
             if (!isAudioEngineRunning && !forceActive) return 0;

             let baseGain = params.masterGain;
             let finalGain = baseGain;
             let modulated = false;

             // --- Y-Position Velocity Proxy ---
             let yPosSum = 0;
             let activePadCount = 0;
             activePointers.forEach(pInfo => {
                 if (padStates[pInfo.padId]?.active) {
                     yPosSum += padStates[pInfo.padId].y; // Y is 0 (bottom) to 1 (top)
                     activePadCount++;
                 }
             });
             let avgYPos = (activePadCount > 0) ? yPosSum / activePadCount : 0.5; // Default to center if no active pads
             // Scale gain slightly: 0.7 at bottom (y=0), 1.0 at center (y=0.5), 1.3 at top (y=1)
             // Adjust the scaling factor (0.6 here) to control sensitivity
             const yPosGainScale = 1.0 + (avgYPos - 0.5) * 0.6;
             finalGain *= yPosGainScale; // Apply Y-position scaling to base gain before mods

             // --- Apply Modulations ---
             // Get current modulation inputs
             const x1_st = padStates.pad1.x, y1_st = padStates.pad1.y;
             const x2_st = padStates.pad2.x, y2_st = padStates.pad2.y;
             const slL_st = sliderStates.sliderL - 0.5;
             const lfo1_st = lfo1Gain ? lfo1Gain.gain.value : 0;
             const lfo2_st = lfo2Gain ? lfo2Gain.gain.value : 0;
             const harmLFO_st = harmonyLFOGain ? harmonyLFOGain.gain.value : 0;

             const modValuesNow = { x1: x1_st, y1: y1_st, x2: x2_st, y2: y2_st, sliderL: slL_st, lfo1: lfo1_st, lfo2: lfo2_st, harmonyLFO: harmLFO_st };

             modSources.forEach(source => {
                 if (source === 'sliderR') return; // Chaos slider excluded from direct volume mod
                 const modData = modMatrix[source];
                 if (modData && modData.target === 'mainVol') {
                     // Check if the source is 'active'
                     let sourceActive = false;
                     if (source === 'x1' || source === 'y1') sourceActive = padStates.pad1.active;
                     else if (source === 'x2' || source === 'y2') sourceActive = padStates.pad2.active;
                     else if (source === 'sliderL' || source.startsWith('lfo')) sourceActive = true;

                     if (sourceActive || forceActive) {
                         let modInput = modValuesNow[source] ?? 0;
                         let amount = modData.amount ?? 0;
                         if (typeof amount === 'number') {
                             finalGain += modInput * amount;
                             modulated = true;
                         }
                     }
                 }
             });

             // Clamp final gain after Y-pos scaling and modulation
             return clamp(finalGain, 0, 1.0); // Strict 0-1 clamp
         }

        // --- Event Handling (Sliders - Same as before) ---
         sliderL.addEventListener('input', (e) => {
             sliderStates.sliderL = parseFloat(e.target.value) / 100;
            if (isAudioEngineRunning) updateSynthParams();
         });
        sliderR.addEventListener('input', (e) => {
            sliderStates.sliderR = parseFloat(e.target.value) / 100;
            if (isAudioEngineRunning) updateSynthParams();
         });
        const snapbackSliderL = () => {
            sliderL.value = 50;
            sliderStates.sliderL = 0.5;
            if (isAudioEngineRunning) updateSynthParams();
        };
        sliderL.addEventListener('pointerup', snapbackSliderL);
        sliderL.addEventListener('touchend', snapbackSliderL);
        sliderL.addEventListener('keyup', (e) => { if (['ArrowUp', 'ArrowDown'].includes(e.key)) snapbackSliderL(); });


        // --- Event Handling (Top Controls - Same structure) ---
         randomizeButton.addEventListener('click', () => {
             randomizeSeed(); // Handles init/resume internally
         });
         recallSeedButton.addEventListener('click', () => {
             const seedInput = prompt("Enter Seed Number:", currentSeed || '');
            if (seedInput !== null) {
                 const seedNum = parseInt(seedInput.trim(), 10);
                 if (!isNaN(seedNum)) {
                     randomizeSeed(seedNum); // Handles init/resume internally
                 } else {
                     alert("Invalid seed number.");
                 }
             }
         });
        keySelector.addEventListener('change', (e) => {
            currentKey = e.target.value;
             console.log("Key changed to:", currentKey);
             params.baseFrequency = keyFrequencies[currentKey];
             if (audioContext && audioContext.state === 'running') {
                 // Update additive synth immediately for new key
                 updateAdditiveHarmonics();
                 // Update other params based on new key
                 updateSynthParams(true); // Force update with new base frequency
             }
        });


        // --- Initial Setup (Same Structure) ---
        function setupControls() {
            keySelector.innerHTML = '';
            Object.keys(keyFrequencies).forEach(key => {
                 const option = document.createElement('option');
                 option.value = key; option.textContent = key;
                 keySelector.appendChild(option);
             });
            keySelector.value = currentKey;
             sliderL.value = sliderStates.sliderL * 100;
             sliderR.value = sliderStates.sliderR * 100;
             seedDisplay.textContent = 'N/A'; // Initial seed display
        }

        // --- Global Event Listeners (Same as before) ---
        const mainContent = document.getElementById('main-content');
        mainContent.addEventListener('pointerdown', handlePointerDown);
        mainContent.addEventListener('pointermove', handlePointerMove);
        mainContent.addEventListener('pointerup', handlePointerUpOrLeave);
        mainContent.addEventListener('pointercancel', handlePointerUpOrLeave);
        mainContent.addEventListener('pointerleave', handlePointerUpOrLeave);


         // --- Initial Load ---
         window.addEventListener('DOMContentLoaded', () => {
             setupControls();
             console.log("Contemplation Engine DOM loaded. Landscape enforced via CSS.");
             console.log("Audio Engine will initialize on first user interaction.");
             // Don't randomize or init audio here - wait for user interaction in handlePointerDown
         });

    </script>

</body>
</html>